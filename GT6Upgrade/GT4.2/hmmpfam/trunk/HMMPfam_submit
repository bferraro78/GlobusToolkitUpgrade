#!/usr/bin/perl

use strict;
use Cwd;
use GSBL::Client ':all';

use FindBin qw($RealBin);
use lib "$RealBin/../lib";

my %option_desc = ( 


	Z => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "calcEValue",
		 TAKES => qq{n},
		 DESC => qq{Calculate the E-value scores as if we had a sequence database of n sequences},
	},

	cut_ga => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "cutGA",
		 DESC => qq{Use gathering threshold to score cutoffs},
	},

	informat => { 	TYPE => "s",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "informat",
		 TAKES => qq{s},
		 DESC => qq{Assert that the input sequence file is in format s.  Valid format strings include: FASTA, GENBANK, EMBL, GCG, PIR, STOCKHOLM, SELEX, MSF, CLUSTAL, and PHYLIP.},
	},

	forward => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "forward",
		 DESC => qq{Use the Forward algorithm instead of the Viterbi algorithm to determine the per-sequence scores},
	},

	xnu => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "xnu",
		 DESC => qq{Turn on XNU filtering of target protein sequences.},
	},

	cut_tc => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "cutTC",
		 DESC => qq{Use trusted cutoff to score cutoffs},
	},

	acc => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "acc",
		 DESC => qq{Report HMM accessions instead of names in the output},
	},

	E => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "setEValue",
		 TAKES => qq{x},
		 DESC => qq{Set the E-value cutoff for the per-sequence ranked hit list to x},
	},

	domT => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "domT",
		 TAKES => qq{x},
		 DESC => qq{Set the bit score cutoff for the per-domain ranked hit list to x.},
	},

	arg1 => { 	TYPE => "s",
		 OPTIONAL_FLAG => "0",
		 OPTIONAL_VALUE => "0",
		 KEY => "seqFastaFile",
		 TAKES => qq{seq_file(s)},
		 DESC => qq{The sequence file. Can be gzip},
	},

	arg0 => { 	TYPE => "s",
		 OPTIONAL_FLAG => "0",
		 OPTIONAL_VALUE => "0",
		 KEY => "hmmFile",
		 TAKES => qq{pfam_file(s)},
		 DESC => qq{The HMM Pfam file},
	},

	A => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "alignment",
		 TAKES => qq{n},
		 DESC => qq{Limits the alignment output to the n best scoring domains},
	},

	null2 => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "null2",
		 DESC => qq{Turn off the post hoc second null model},
	},

	suppress => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "suppress",
		 DESC => qq{Suppress negative hits from the output.},
	},

	domE => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "domE",
		 TAKES => qq{x},
		 DESC => qq{Set the E-value cutoff for the per-domain ranked hit list to x.},
	},

	cpu => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "cpu",
		 TAKES => qq{n},
		 DESC => qq{Sets the maximum number of CPUs used to n},
	},

	replicates => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "replicates",
		 TAKES => qq{replicates},
		 DESC => qq{The number of times to execute this job.},
	},

	arg2 => { 	TYPE => "s",
		 OPTIONAL_FLAG => "0",
		 OPTIONAL_VALUE => "0",
		 KEY => "output",
		 TAKES => qq{output_file},
		 DESC => qq{Redirect stdout to this filename.},
	},

	T => { 	TYPE => "i",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "bitScore",
		 TAKES => qq{x},
		 DESC => qq{Set the bit score cutoff for the per-sequence ranked hit list to x},
	},

	compat => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "compat",
		 DESC => qq{Use the output format of HMMER 2.1.1},
	},

	cut_nc => { 	TYPE => "none",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "1",
		 KEY => "cutNC",
		 DESC => qq{Use noise cutoff to score cutoffs},
	},

	jobname => { 	TYPE => "s",
		 OPTIONAL_FLAG => "1",
		 OPTIONAL_VALUE => "0",
		 KEY => "jobname",
		 TAKES => qq{jobname},
		 DESC => qq{The arbitrary name to assign this job or batch of jobs.},
	},


);

my $properties = process_options(\%option_desc, "HMMPfam");

my $pid = $$;
my $jobname = "not initialized";

if($properties =~ /jobname \@-- (.*) \@-- java.lang.String/) { # override job name
    $jobname = $1;
    my @properties_chunks = split(/\n/, $properties);
    my $new_properties = "";
    foreach my $chunk(@properties_chunks) {
	if(!($chunk =~ /jobname.*java.lang.String/)) {
	    $new_properties .= $chunk . "\n";
	}
    }
    $properties = $new_properties;
} else {
    my $wd = getcwd;
    $wd =~ /.*\/(.*)/;
    $wd = $1;
    $jobname = $wd;
}

open(PROPERTIES_OUT, ">HMMPfam.properties.$pid") || die "Cannot write properties file: $!";
print PROPERTIES_OUT $properties;
close(PROPERTIES_OUT);

system("java -DGLOBUS_LOCATION=\$GLOBUS_LOCATION -classpath $RealBin:$RealBin/build/classes/:$RealBin/build/stubs/classes/:\$CLASSPATH edu.umd.grid.bio.hmmpfam.clients.HMMPfamSubmitClient https://lysine.umiacs.umd.edu:8443/wsrf/services/edu/umd/grid/bio/hmmpfam/HMMPfamFactoryService HMMPfam.properties.$pid $jobname");

unlink("HMMPfam.properties.$$");

